<div class="inventory-container">
  <div class="inventory-header">
    <h2 class="glitch-text">Survivor Inventory</h2>
    <p class="subtitle" id="char-name">Loading character data...</p>
  </div>

  <div class="inventory-sections">
    <div class="inventory-section equipment-section">
      <h3>Equipment</h3>
      <div class="equipment-slots">
        <div class="equipment-slot head-slot" data-slot="head">
          <div class="slot-label">Head</div>
          <div class="slot-image" id="head-slot">
            <img src="/images/slots/head-empty.png" alt="Head slot" class="empty-slot">
          </div>
        </div>
        <div class="equipment-slot body-slot" data-slot="body">
          <div class="slot-label">Body</div>
          <div class="slot-image" id="body-slot">
            <img src="/images/slots/body-empty.png" alt="Body slot" class="empty-slot">
          </div>
        </div>
        <div class="equipment-slot hands-slot" data-slot="hands">
          <div class="slot-label">Hands</div>
          <div class="slot-image" id="hands-slot">
            <img src="/images/slots/hands-empty.png" alt="Hands slot" class="empty-slot">
          </div>
        </div>
        <div class="equipment-slot legs-slot" data-slot="legs">
          <div class="slot-label">Legs</div>
          <div class="slot-image" id="legs-slot">
            <img src="/images/slots/legs-empty.png" alt="Legs slot" class="empty-slot">
          </div>
        </div>
        <div class="equipment-slot feet-slot" data-slot="feet">
          <div class="slot-label">Feet</div>
          <div class="slot-image" id="feet-slot">
            <img src="/images/slots/feet-empty.png" alt="Feet slot" class="empty-slot">
          </div>
        </div>
        <div class="equipment-slot weapon-slot" data-slot="weapon">
          <div class="slot-label">Weapon</div>
          <div class="slot-image" id="weapon-slot">
            <img src="/images/slots/weapon-empty.png" alt="Weapon slot" class="empty-slot">
          </div>
        </div>
        <div class="equipment-slot accessory-slot" data-slot="accessory">
          <div class="slot-label">Accessory</div>
          <div class="slot-image" id="accessory-slot">
            <img src="/images/slots/accessory-empty.png" alt="Accessory slot" class="empty-slot">
          </div>
        </div>
      </div>
    </div>

    <div class="inventory-section items-section">
      <h3>Inventory <span id="inventory-count">0/20</span></h3>
      <div class="inventory-grid" id="inventory-grid">
        <!-- Inventory slots will be populated by JavaScript -->
      </div>
    </div>

    <div class="inventory-section item-details-section">
      <h3>Item Details</h3>
      <div class="item-details" id="item-details">
        <p class="no-item-selected">Select an item to view details</p>
      </div>
      <div class="item-actions" id="item-actions">
        <!-- Actions will be populated by JavaScript -->
      </div>
    </div>
  </div>

  <div class="inventory-footer">
    <a href="/dashboard" class="back-button glow-button">Back to Dashboard</a>
  </div>
</div>

<!-- Item tooltip template -->
<div id="item-tooltip" class="tooltip" style="display: none; z-index: 9999;"></div>

<script>
  document.addEventListener('DOMContentLoaded', async () => {
    // Add debug info container
    const debugInfo = document.createElement('div');
    debugInfo.id = 'debug-info';
    debugInfo.style.display = 'none';
    debugInfo.innerHTML = '<h3>Debug Information</h3><div id="debug-content"></div>';
    document.querySelector('.inventory-container').appendChild(debugInfo);
    
    const addDebugInfo = (message) => {
      const debugContent = document.getElementById('debug-content');
      debugContent.innerHTML += `<p>${message}</p>`;
    };
    
    // Check authentication
    addDebugInfo('Checking authentication...');
    
    // Get character data and inventory
    try {
      addDebugInfo('Fetching character data...');
      const characterRes = await fetch('/api/character', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        },
        credentials: 'include' // Important: Include cookies for authentication
      });
      
      addDebugInfo(`Character API status: ${characterRes.status}`);
      
      if (!characterRes.ok) {
        throw new Error(`Character API returned ${characterRes.status}: ${await characterRes.text()}`);
      }
      
      const characterData = await characterRes.json();
      
      if (characterData.success) {
        // Update character name
        document.getElementById('char-name').textContent = characterData.data.name;
        addDebugInfo(`Character found: ${characterData.data.name}`);
      } else {
        addDebugInfo(`Character API error: ${characterData.message}`);
      }
      
      addDebugInfo('Fetching inventory data...');
      const inventoryRes = await fetch('/api/inventory', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        },
        credentials: 'include' // Important: Include cookies for authentication
      });
      
      addDebugInfo(`Inventory API status: ${inventoryRes.status}`);
      
      if (!inventoryRes.ok) {
        throw new Error(`Inventory API returned ${inventoryRes.status}: ${await inventoryRes.text()}`);
      }
      
      const inventoryData = await inventoryRes.json();
      
      if (inventoryData.success) {
        // Render inventory
        addDebugInfo('Inventory data loaded successfully');
        renderInventory(inventoryData.data);
      } else {
        addDebugInfo(`Inventory API error: ${inventoryData.message}`);
        document.getElementById('inventory-grid').innerHTML = '<p class="error-message">Failed to load inventory. Please try refreshing the page.</p>';
      }
    } catch (err) {
      console.error('Error loading data:', err);
      addDebugInfo(`Error: ${err.message}`);
      document.getElementById('inventory-grid').innerHTML = '<p class="error-message">Error loading inventory: ' + err.message + '</p>';
      
      // Show debug info when there's an error
      document.getElementById('debug-info').style.display = 'block';
    }
  });
  
  // Render the inventory and equipment
  function renderInventory(data) {
    // Update inventory count
    const inventoryCount = document.getElementById('inventory-count');
    inventoryCount.textContent = `${data.inventory.length}/${data.inventorySize}`;
    
    // Render equipment slots
    renderEquipment(data.equipment);
    
    // Render inventory grid
    renderInventoryGrid(data.inventory, data.inventorySize);
    
    // Setup event listeners for inventory interactions
    setupInventoryInteractions();
  }
  
  // Render equipment slots
  function renderEquipment(equipment) {
    const slots = ['head', 'body', 'hands', 'legs', 'feet', 'weapon', 'accessory'];
    
    slots.forEach(slot => {
      const slotElement = document.getElementById(`${slot}-slot`);
      
      if (equipment[slot]) {
        // Item is equipped
        const item = equipment[slot];
        const imageSrc = item.image.startsWith('/images/items/') ? 
          item.image : 
          `/images/items/${item.image}`;
        
        slotElement.innerHTML = `
          <img src="${imageSrc}" alt="${item.name}" class="equipped-item" data-item-id="${item._id}">
        `;
      } else {
        // Empty slot
        slotElement.innerHTML = `
          <img src="/images/slots/${slot}-empty.png" alt="${slot} slot" class="empty-slot">
        `;
      }
    });
  }
  
  // Render inventory grid
  function renderInventoryGrid(inventory, inventorySize) {
    const inventoryGrid = document.getElementById('inventory-grid');
    inventoryGrid.innerHTML = '';
    
    // Create all slots (including empty ones)
    for (let i = 0; i < inventorySize; i++) {
      const inventorySlot = document.createElement('div');
      inventorySlot.className = 'inventory-slot';
      inventorySlot.dataset.slotIndex = i;
      
      // If there's an item in this slot
      if (i < inventory.length) {
        const inventoryItem = inventory[i];
        const item = inventoryItem.item;
        
        // Fix image path to avoid duplication
        const imageSrc = item.image.startsWith('/images/items/') ? 
          item.image : 
          `/images/items/${item.image}`;
        
        inventorySlot.innerHTML = `
          <div class="item" data-inventory-id="${inventoryItem._id}" data-item-id="${item._id}">
            <img src="${imageSrc}" alt="${item.name}">
            ${inventoryItem.quantity > 1 ? `<div class="item-quantity">${inventoryItem.quantity}</div>` : ''}
          </div>
        `;
        
        // Add rarity class
        inventorySlot.querySelector('.item').classList.add(`rarity-${item.rarity}`);
      }
      
      inventoryGrid.appendChild(inventorySlot);
    }
  }
  
  // Setup event listeners for inventory interactions
  function setupInventoryInteractions() {
    const inventorySlots = document.querySelectorAll('.inventory-slot');
    const equipmentSlots = document.querySelectorAll('.equipment-slot');
    const tooltip = document.getElementById('item-tooltip');
    
    // Setup for inventory items
    inventorySlots.forEach(slot => {
      const itemElement = slot.querySelector('.item');
      
      if (itemElement) {
        // Show tooltip on hover - improved error handling for inventory items
        itemElement.addEventListener('mouseenter', async (e) => {
          const inventoryId = itemElement.dataset.inventoryId;
          
          // Position tooltip initially at a fixed offset from cursor
          tooltip.style.left = `${e.clientX + 15}px`;
          tooltip.style.top = `${e.clientY + 15}px`;
          
          // Show loading state
          tooltip.innerHTML = '<div class="tooltip-header">Loading...</div>';
          tooltip.style.display = 'block';
          
          // Get item details
          try {
            const res = await fetch(`/api/inventory/item/${inventoryId}`, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json'
              },
              credentials: 'include'
            });
            
            const data = await res.json();
            
            if (data.success) {
              const item = data.data;
              
              // Build the tooltip content
              tooltip.innerHTML = buildItemTooltip(item);
              
              // Reposition tooltip after content is loaded
              const rect = e.target.getBoundingClientRect();
              const tooltipRect = tooltip.getBoundingClientRect();
              
              // Adjust position to not overlap with the item
              let left = rect.right + 10;
              let top = rect.top;
              
              // Check if tooltip would go off right edge of screen
              if (left + tooltipRect.width > window.innerWidth - 10) {
                left = rect.left - tooltipRect.width - 10;
              }
              
              // Check if tooltip would go off bottom edge of screen
              if (top + tooltipRect.height > window.innerHeight - 10) {
                top = window.innerHeight - tooltipRect.height - 10;
              }
              
              // Ensure tooltip doesn't go off the left or top of the screen
              left = Math.max(10, left);
              top = Math.max(10, top);
              
              tooltip.style.left = `${left}px`;
              tooltip.style.top = `${top}px`;
            } else {
              tooltip.innerHTML = '<div class="tooltip-header">Error</div><div class="tooltip-content">Failed to load item details</div>';
            }
          } catch (err) {
            console.error('Error fetching item details for tooltip:', err);
            tooltip.innerHTML = '<div class="tooltip-header">Error</div><div class="tooltip-content">Failed to load item details</div>';
          }
        });
        
        // Update tooltip position on mousemove with improved positioning
        itemElement.addEventListener('mousemove', (e) => {
          if (tooltip.style.display === 'block') {
            // Position tooltip relative to mouse cursor, but stay within viewport
            const tooltipWidth = tooltip.offsetWidth || 200; // Fallback width if not rendered yet
            const tooltipHeight = tooltip.offsetHeight || 100; // Fallback height if not rendered yet
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Calculate best position to avoid going off-screen
            let left = e.clientX + 15;
            let top = e.clientY + 15;
            
            // Adjust if tooltip would go off right edge
            if (left + tooltipWidth > viewportWidth - 10) {
              left = e.clientX - tooltipWidth - 10;
            }
            
            // Adjust if tooltip would go off bottom edge
            if (top + tooltipHeight > viewportHeight - 10) {
              top = viewportHeight - tooltipHeight - 10;
            }
            
            // Ensure tooltip stays visible (never position off-screen)
            left = Math.max(10, left);
            top = Math.max(10, top);
            
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
          }
        });
        
        // Hide tooltip on mouseout
        itemElement.addEventListener('mouseleave', () => {
          tooltip.style.display = 'none';
        });
        
        // Show item details on click
        itemElement.addEventListener('click', () => {
          showItemDetails(itemElement.dataset.inventoryId, 'inventory');
        });
      }
    });
    
    // Setup for equipment items
    equipmentSlots.forEach(slot => {
      const itemElement = slot.querySelector('.equipped-item');
      
      if (itemElement) {
        // Show tooltip on hover - improved error handling for equipped items
        itemElement.addEventListener('mouseenter', async (e) => {
          // Position tooltip initially at a fixed offset from cursor
          tooltip.style.left = `${e.clientX + 15}px`;
          tooltip.style.top = `${e.clientY + 15}px`;
          
          // Show loading state
          tooltip.innerHTML = '<div class="tooltip-header">Loading...</div>';
          tooltip.style.display = 'block';
          
          // Get item details
          try {
            const res = await fetch(`/api/inventory/equipped/${slot.dataset.slot}`, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json'
              },
              credentials: 'include'
            });
            
            const data = await res.json();
            
            if (data.success) {
              const item = data.data;
              
              // Build the tooltip content
              tooltip.innerHTML = buildItemTooltip(item);
              
              // Reposition tooltip after content is loaded
              const rect = e.target.getBoundingClientRect();
              const tooltipRect = tooltip.getBoundingClientRect();
              
              // Adjust position to not overlap with the item
              let left = rect.right + 10;
              let top = rect.top;
              
              // Check if tooltip would go off right edge of screen
              if (left + tooltipRect.width > window.innerWidth - 10) {
                left = rect.left - tooltipRect.width - 10;
              }
              
              // Check if tooltip would go off bottom edge of screen
              if (top + tooltipRect.height > window.innerHeight - 10) {
                top = window.innerHeight - tooltipRect.height - 10;
              }
              
              // Ensure tooltip doesn't go off the left or top of the screen
              left = Math.max(10, left);
              top = Math.max(10, top);
              
              tooltip.style.left = `${left}px`;
              tooltip.style.top = `${top}px`;
            } else {
              tooltip.innerHTML = '<div class="tooltip-header">Error</div><div class="tooltip-content">Failed to load item details</div>';
            }
          } catch (err) {
            console.error('Error fetching item details for tooltip:', err);
            tooltip.innerHTML = '<div class="tooltip-header">Error</div><div class="tooltip-content">Failed to load item details</div>';
          }
        });
        
        // Update tooltip position on mousemove with improved positioning
        itemElement.addEventListener('mousemove', (e) => {
          if (tooltip.style.display === 'block') {
            // Position tooltip relative to mouse cursor, but stay within viewport
            const tooltipWidth = tooltip.offsetWidth || 200; // Fallback width if not rendered yet
            const tooltipHeight = tooltip.offsetHeight || 100; // Fallback height if not rendered yet
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Calculate best position to avoid going off-screen
            let left = e.clientX + 15;
            let top = e.clientY + 15;
            
            // Adjust if tooltip would go off right edge
            if (left + tooltipWidth > viewportWidth - 10) {
              left = e.clientX - tooltipWidth - 10;
            }
            
            // Adjust if tooltip would go off bottom edge
            if (top + tooltipHeight > viewportHeight - 10) {
              top = viewportHeight - tooltipHeight - 10;
            }
            
            // Ensure tooltip stays visible (never position off-screen)
            left = Math.max(10, left);
            top = Math.max(10, top);
            
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
          }
        });
        
        // Hide tooltip on mouseout
        itemElement.addEventListener('mouseleave', () => {
          tooltip.style.display = 'none';
        });
        
        // Show item details on click
        itemElement.addEventListener('click', () => {
          showItemDetails(itemElement.dataset.itemId, 'equipment', slot.dataset.slot);
        });
      }
    });
  }
  
  // Helper function to build consistent item tooltips - Simplified for clarity
  function buildItemTooltip(item) {
    // Ensure stats object exists
    if (!item.stats) {
      item.stats = {};
    }

    return `
      <div class="tooltip-header">${item.name}</div>
      <div class="tooltip-content">
        <div class="tooltip-type">${capitalizeFirstLetter(item.type)}${item.subType ? ` (${capitalizeFirstLetter(item.subType)})` : ''}</div>
        <div class="tooltip-description">${item.description}</div>
      </div>
    `;
  }
  
  // Helper function to render tooltip stats based on item type - keep this for detailed view in the panel
  function renderTooltipStats(item) {
    if (item.type === 'consumable') {
      return `
        <div class="tooltip-stats">
          ${item.stats.healthBonus ? `
            <div class="tooltip-stat ${item.stats.healthBonus > 0 ? 'positive' : 'negative'}">
              <span class="stat-name">Health:</span>
              <span class="stat-value">${item.stats.healthBonus > 0 ? '+' : ''}${item.stats.healthBonus}</span>
            </div>` : ''}
          ${item.stats.hungerRestore ? `
            <div class="tooltip-stat positive">
              <span class="stat-name">Hunger:</span>
              <span class="stat-value">+${item.stats.hungerRestore}</span>
            </div>` : ''}
          ${item.stats.thirstRestore ? `
            <div class="tooltip-stat positive">
              <span class="stat-name">Thirst:</span>
              <span class="stat-value">+${item.stats.thirstRestore}</span>
            </div>` : ''}
          ${item.stats.radiationEffect ? `
            <div class="tooltip-stat ${item.stats.radiationEffect < 0 ? 'positive' : 'negative'}">
              <span class="stat-name">Radiation:</span>
              <span class="stat-value">${item.stats.radiationEffect > 0 ? '+' : ''}${item.stats.radiationEffect}</span>
            </div>` : ''}
          ${(!item.stats.healthBonus && !item.stats.hungerRestore && !item.stats.thirstRestore && !item.stats.radiationEffect) ? `
            <div class="tooltip-stat">
              <span class="stat-name">Effects:</span>
              <span class="stat-value">None</span>
            </div>` : ''}
        </div>
      `;
    } else if (item.type === 'weapon') {
      return `
        <div class="tooltip-stats">
          <div class="tooltip-stat">
            <span class="stat-name">Damage:</span>
            <span class="stat-value">${item.stats.damage || 0}</span>
          </div>
        </div>
      `;
    } else if (item.type === 'armor') {
      return `
        <div class="tooltip-stats">
          <div class="tooltip-stat">
            <span class="stat-name">Defense:</span>
            <span class="stat-value">${item.stats.defense || 0}</span>
          </div>
          <div class="tooltip-stat">
            <span class="stat-name">Rad Resistance:</span>
            <span class="stat-value">${item.stats.radiationResistance || 0}</span>
          </div>
        </div>
      `;
    } else {
      return `
        <div class="tooltip-stats">
          <div class="tooltip-stat">
            <span class="stat-name">Info:</span>
            <span class="stat-value">This item has no special properties</span>
          </div>
        </div>
      `;
    }
  }
  
  // Show item details in the details panel - update to handle undefined stats
  function showItemDetails(itemId, source, slot) {
    const detailsPanel = document.getElementById('item-details');
    const actionsPanel = document.getElementById('item-actions');
    
    // Clear existing content
    detailsPanel.innerHTML = '<p class="loading">Loading item details...</p>';
    actionsPanel.innerHTML = '';
    
    // Fetch item details from the server
    fetch(`/api/inventory/${source === 'inventory' ? 'item/' + itemId : 'equipped/' + slot}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include'
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        const item = data.data;
        
        // Ensure stats object exists
        if (!item.stats) {
          item.stats = {};
        }
        
        // Build the details HTML
        detailsPanel.innerHTML = `
          <div class="item-detail-header">
            <h4>${item.name}</h4>
            <div class="item-rarity rarity-${item.rarity}">${item.rarity.charAt(0).toUpperCase() + item.rarity.slice(1)}</div>
          </div>
          <div class="item-image-preview">
            <img src="${item.image.startsWith('/images/items/') ? item.image : '/images/items/' + item.image}" alt="${item.name}">
          </div>
          <div class="item-description">
            ${item.description}
          </div>
          <div class="item-stats">
            ${renderItemStats(item)}
          </div>
        `;
        
        // Show appropriate actions based on item source and type
        if (source === 'inventory') {
          // Actions for inventory items
          if (item.type === 'consumable') {
            const useButton = document.createElement('button');
            useButton.className = 'action-button glow-button';
            useButton.textContent = 'Use';
            useButton.addEventListener('click', () => useItem(itemId));
            actionsPanel.appendChild(useButton);
          }
          
          if (item.type === 'weapon' || item.type === 'armor' || item.type === 'accessory') {
            const equipButton = document.createElement('button');
            equipButton.className = 'action-button glow-button';
            equipButton.textContent = 'Equip';
            equipButton.addEventListener('click', () => equipItem(itemId));
            actionsPanel.appendChild(equipButton);
          }
          
          const dropButton = document.createElement('button');
          dropButton.className = 'action-button glow-button danger-button';
          dropButton.textContent = 'Drop';
          dropButton.addEventListener('click', () => dropItem(itemId));
          actionsPanel.appendChild(dropButton);
        } else if (source === 'equipment') {
          // Actions for equipped items
          const unequipButton = document.createElement('button');
          unequipButton.className = 'action-button glow-button';
          unequipButton.textContent = 'Unequip';
          unequipButton.addEventListener('click', () => unequipItem(slot));
          actionsPanel.appendChild(unequipButton);
        }
      } else {
        detailsPanel.innerHTML = `<p class="error-message">${data.message || 'Failed to load item details'}</p>`;
      }
    })
    .catch(err => {
      console.error('Error fetching item details:', err);
      detailsPanel.innerHTML = `<p class="error-message">Error loading item details</p>`;
    });
  }
  
  // Helper function to capitalize first letter
  function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  
  // Placeholder functions for item actions
  function useItem(inventoryItemId) {
    console.log('Using item:', inventoryItemId);
    
    fetch('/api/inventory/use', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include',
      body: JSON.stringify({ inventoryItemId })
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        // Show a success message with effects
        let effectsMessage = '';
        
        if (data.data.effects.health > 0) {
          effectsMessage += `+${data.data.effects.health} Health. `;
        }
        
        if (data.data.effects.hunger > 0) {
          effectsMessage += `+${data.data.effects.hunger} Hunger. `;
        }
        
        if (data.data.effects.thirst > 0) {
          effectsMessage += `+${data.data.effects.thirst} Thirst. `;
        }
        
        if (data.data.effects.radiation > 0) {
          effectsMessage += `+${data.data.effects.radiation} Radiation. `;
        } else if (data.data.effects.radiation < 0) {
          effectsMessage += `${data.data.effects.radiation} Radiation. `;
        }
        
        // Show toast with effects
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.innerHTML = `<div>${data.message}</div>${effectsMessage ? `<div class="toast-effects">${effectsMessage}</div>` : ''}`;
        document.body.appendChild(toast);
        
        setTimeout(() => {
          toast.classList.add('show');
        }, 10);
        
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => {
            document.body.removeChild(toast);
          }, 300);
        }, 3000);
        
        // Update the inventory display
        renderInventory({
          inventory: data.data.inventory,
          equipment: {}  // We don't get equipment back, but we're not changing it
        });
        
        // Close the item details
        document.getElementById('item-details').innerHTML = '<p class="no-item-selected">Select an item to view details</p>';
        document.getElementById('item-actions').innerHTML = '';
      } else {
        alert(data.message || 'Failed to use item');
      }
    })
    .catch(err => {
      console.error('Error using item:', err);
      alert('An error occurred while using the item');
    });
  }
  
  function equipItem(inventoryItemId) {
    console.log('Equipping item:', inventoryItemId);
    
    fetch('/api/inventory/equip', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include',
      body: JSON.stringify({ inventoryItemId })
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        // Show success message
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = data.message;
        document.body.appendChild(toast);
        
        setTimeout(() => {
          toast.classList.add('show');
        }, 10);
        
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => {
            document.body.removeChild(toast);
          }, 300);
        }, 3000);
        
        // Update the inventory and equipment display
        if (data.data) {
          renderInventory({
            inventory: data.data.inventory,
            equipment: data.data.equipment
          });
        }
        
        // Close the item details
        document.getElementById('item-details').innerHTML = '<p class="no-item-selected">Select an item to view details</p>';
        document.getElementById('item-actions').innerHTML = '';
      } else {
        alert(data.message || 'Failed to equip item');
      }
    })
    .catch(err => {
      console.error('Error equipping item:', err);
      alert('An error occurred while equipping the item');
    });
  }
  
  function unequipItem(slot) {
    console.log('Unequipping item from slot:', slot);
    
    fetch('/api/inventory/unequip', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'include',
      body: JSON.stringify({ slot })
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        // Show success message
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = data.message;
        document.body.appendChild(toast);
        
        setTimeout(() => {
          toast.classList.add('show');
        }, 10);
        
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => {
            document.body.removeChild(toast);
          }, 300);
        }, 3000);
        
        // Update the inventory and equipment display
        if (data.data) {
          renderInventory({
            inventory: data.data.inventory,
            equipment: data.data.equipment
          });
        }
        
        // Close the item details
        document.getElementById('item-details').innerHTML = '<p class="no-item-selected">Select an item to view details</p>';
        document.getElementById('item-actions').innerHTML = '';
      } else {
        alert(data.message || 'Failed to unequip item');
      }
    })
    .catch(err => {
      console.error('Error unequipping item:', err);
      alert('An error occurred while unequipping the item');
    });
  }
  
  function dropItem(inventoryItemId) {
    if (confirm('Are you sure you want to drop this item? This cannot be undone.')) {
      console.log('Dropping item:', inventoryItemId);
      
      fetch('/api/inventory/remove', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        credentials: 'include',
        body: JSON.stringify({ inventoryItemId })
      })
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          // Show success message
          const toast = document.createElement('div');
          toast.className = 'toast';
          toast.textContent = data.message;
          document.body.appendChild(toast);
          
          setTimeout(() => {
            toast.classList.add('show');
          }, 10);
          
          setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
              document.body.removeChild(toast);
            }, 300);
          }, 3000);
          
          // Update the inventory display
          if (data.data) {
            renderInventory({
              inventory: data.data,
              equipment: {}  // We don't get equipment back, but we're not changing it
            });
          }
          
          // Close the item details
          document.getElementById('item-details').innerHTML = '<p class="no-item-selected">Select an item to view details</p>';
          document.getElementById('item-actions').innerHTML = '';
        } else {
          alert(data.message || 'Failed to drop item');
        }
      })
      .catch(err => {
        console.error('Error dropping item:', err);
        alert('An error occurred while dropping the item');
      });
    }
  }
  
  // Render item stats based on item type - used for item details panel
  function renderItemStats(item) {
    // Make sure stats object exists to prevent errors
    if (!item.stats) {
      item.stats = {};
    }
    
    let statsHTML = `
      <div class="item-stat">
        <span class="stat-name">Type:</span>
        <span class="stat-value">${capitalizeFirstLetter(item.type)}${item.subType ? ` (${capitalizeFirstLetter(item.subType)})` : ''}</span>
      </div>
      <div class="item-stat">
        <span class="stat-name">Weight:</span>
        <span class="stat-value">${item.weight}</span>
      </div>
      <div class="item-stat">
        <span class="stat-name">Value:</span>
        <span class="stat-value">${item.value}</span>
      </div>
    `;
    
    // Add type-specific stats
    if (item.type === 'weapon') {
      statsHTML += `
        <div class="item-stat">
          <span class="stat-name">Damage:</span>
          <span class="stat-value">${item.stats.damage || 0}</span>
        </div>
      `;
    } else if (item.type === 'armor') {
      statsHTML += `
        <div class="item-stat">
          <span class="stat-name">Defense:</span>
          <span class="stat-value">${item.stats.defense || 0}</span>
        </div>
        <div class="item-stat">
          <span class="stat-name">Rad Resistance:</span>
          <span class="stat-value">${item.stats.radiationResistance || 0}</span>
        </div>
      `;
    }
    
    // Add consumable stats (if applicable) - for all item types that might have these effects
    if (item.stats.healthBonus) {
      statsHTML += `
        <div class="item-stat ${item.stats.healthBonus > 0 ? 'positive' : 'negative'}">
          <span class="stat-name">Health:</span>
          <span class="stat-value">${item.stats.healthBonus > 0 ? '+' : ''}${item.stats.healthBonus}</span>
        </div>
      `;
    }
    
    if (item.stats.hungerRestore) {
      statsHTML += `
        <div class="item-stat positive">
          <span class="stat-name">Hunger:</span>
          <span class="stat-value">+${item.stats.hungerRestore}</span>
        </div>
      `;
    }
    
    if (item.stats.thirstRestore) {
      statsHTML += `
        <div class="item-stat positive">
          <span class="stat-name">Thirst:</span>
          <span class="stat-value">+${item.stats.thirstRestore}</span>
        </div>
      `;
    }
    
    if (item.stats.radiationEffect) {
      statsHTML += `
        <div class="item-stat ${item.stats.radiationEffect < 0 ? 'positive' : 'negative'}">
          <span class="stat-name">Radiation:</span>
          <span class="stat-value">${item.stats.radiationEffect < 0 ? '' : '+'}${item.stats.radiationEffect}</span>
        </div>
      `;
    }
    
    // Add message for resources or items with no special properties
    if (item.type === 'resource' && !item.stats.healthBonus && !item.stats.hungerRestore && 
        !item.stats.thirstRestore && !item.stats.radiationEffect && !item.stats.damage && !item.stats.defense) {
      statsHTML += `
        <div class="item-stat">
          <span class="stat-name">Info:</span>
          <span class="stat-value">This item has no special properties</span>
        </div>
      `;
    }
    
    return statsHTML;
  }
</script>

<style>
  /* Additional inventory-specific styles */
  .inventory-container {
    padding: 1rem 0;
  }
  
  .inventory-header {
    text-align: center;
    margin-bottom: 2rem;
  }
  
  .inventory-sections {
    display: grid;
    grid-template-columns: 1fr 2fr;
    grid-template-rows: auto 1fr;
    gap: 1.5rem;
    position: relative;
  }
  
  .equipment-section {
    grid-row: span 2;
  }
  
  .inventory-section {
    background-color: var(--background-darker);
    border: 1px solid var(--border-color);
    padding: 1.5rem;
    border-radius: 5px;
  }
  
  .inventory-section h3 {
    color: var(--toxic-green);
    margin-bottom: 1.5rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 0.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  /* Equipment slots */
  .equipment-slots {
    display: grid;
    grid-template-areas:
      ". head ."
      "weapon body accessory"
      ". hands ."
      ". legs ."
      ". feet .";
    gap: 1rem;
    justify-items: center;
  }
  
  .equipment-slot {
    width: 80px;
    height: 80px;
    border: 1px solid var(--border-color);
    background-color: rgba(30, 30, 30, 0.8);
    display: flex;
    flex-direction: column;
    align-items: center;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .equipment-slot:hover {
    border-color: var(--toxic-green);
    box-shadow: 0 0 10px rgba(90, 255, 21, 0.3);
  }
  
  .slot-label {
    font-size: 0.8rem;
    color: #888;
    margin-bottom: 0.3rem;
  }
  
  .slot-image {
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .slot-image img {
    max-width: 100%;
    max-height: 100%;
  }
  
  .empty-slot {
    opacity: 0.3;
  }
  
  /* Slot positioning */
  .head-slot { grid-area: head; }
  .body-slot { grid-area: body; }
  .hands-slot { grid-area: hands; }
  .legs-slot { grid-area: legs; }
  .feet-slot { grid-area: feet; }
  .weapon-slot { grid-area: weapon; }
  .accessory-slot { grid-area: accessory; }
  
  /* Inventory grid */
  .inventory-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 0.5rem;
    position: relative;
    z-index: 1;
    margin-bottom: 15px;
  }
  
  .inventory-slot {
    width: 100%;
    aspect-ratio: 1;
    border: 1px solid var(--border-color);
    background-color: rgba(30, 30, 30, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 3px;
    position: relative;
    z-index: 2;
    margin: 0;
    padding: 0;
  }
  
  .inventory-slot .item {
    width: 80%;
    height: 80%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
    z-index: 3;
  }
  
  .inventory-slot .item img {
    max-width: 85%;
    max-height: 85%;
    object-fit: contain;
  }
  
  .item-quantity {
    position: absolute;
    bottom: -5px;
    right: -5px;
    background-color: var(--background-darker);
    border: 1px solid var(--border-color);
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    z-index: 4;
  }
  
  /* Item rarity styles */
  .rarity-common {
    border: 1px solid #aaa;
  }
  
  .rarity-uncommon {
    border: 1px solid #0a0;
    box-shadow: 0 0 5px rgba(0, 170, 0, 0.5);
  }
  
  .rarity-rare {
    border: 1px solid #00a;
    box-shadow: 0 0 5px rgba(0, 0, 170, 0.5);
  }
  
  .rarity-epic {
    border: 1px solid #a0a;
    box-shadow: 0 0 5px rgba(170, 0, 170, 0.5);
  }
  
  .rarity-legendary {
    border: 1px solid #aa0;
    box-shadow: 0 0 8px rgba(170, 170, 0, 0.7);
    animation: legendary-pulse 2s infinite;
  }
  
  @keyframes legendary-pulse {
    0%, 100% {
      box-shadow: 0 0 8px rgba(170, 170, 0, 0.7);
    }
    50% {
      box-shadow: 0 0 15px rgba(170, 170, 0, 0.9);
    }
  }
  
  /* Item details */
  .no-item-selected {
    color: #888;
    text-align: center;
    padding: 2rem 0;
  }
  
  .item-detail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
  }
  
  .item-rarity {
    font-size: 0.8rem;
    padding: 0.2rem 0.5rem;
    border-radius: 3px;
    background-color: rgba(30, 30, 30, 0.8);
  }
  
  .item-description {
    margin-bottom: 1.5rem;
    line-height: 1.4;
  }
  
  .item-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 15px;
    padding: 10px;
    background-color: rgba(20, 20, 20, 0.5);
    border-radius: 5px;
    border: 1px solid rgba(100, 100, 100, 0.3);
  }
  
  .item-stat {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: rgba(30, 30, 30, 0.8);
    padding: 8px 10px;
    border-radius: 3px;
    overflow: hidden; /* Prevent content from spilling out */
    width: 100%; /* Ensure full width */
    box-sizing: border-box; /* Include padding in width calculation */
  }
  
  .stat-name {
    color: #888;
    font-size: 13px;
    flex: 0 0 auto; /* Don't shrink */
    margin-right: 5px; /* Add some spacing */
  }
  
  .stat-value {
    color: #fff;
    font-weight: bold;
    font-size: 13px;
    text-align: right;
    flex: 0 0 auto; /* Don't shrink */
  }
  
  /* Item image preview */
  .item-image-preview {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: rgba(10, 10, 10, 0.5);
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    height: 120px;
  }
  
  .item-image-preview img {
    max-width: 100px;
    max-height: 100px;
    object-fit: contain;
  }
  
  /* Positive and negative effects */
  .item-stat.positive {
    background-color: rgba(30, 50, 30, 0.8);
    border-left: 3px solid #5aff5a;
  }
  
  .item-stat.negative {
    background-color: rgba(50, 30, 30, 0.8);
    border-left: 3px solid #ff5a5a;
  }
  
  .item-stat.positive .stat-value {
    color: #5aff5a;
  }
  
  .item-stat.negative .stat-value {
    color: #ff5a5a;
  }
  
  /* Loading indicator */
  .loading {
    text-align: center;
    color: #888;
    padding: 1rem 0;
  }
  
  /* Tooltip styles - Better positioning and cleaner look */
  .tooltip {
    position: fixed;
    z-index: 9999;
    background-color: rgba(10, 10, 10, 0.95);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    padding: 10px;
    min-width: 200px;
    max-width: 250px;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
    pointer-events: none;
    font-family: 'Courier New', monospace;
  }
  
  .tooltip-header {
    color: var(--toxic-green);
    font-weight: bold;
    font-size: 14px;
    margin-bottom: 5px;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(100, 100, 100, 0.3);
  }
  
  .tooltip-content {
    font-size: 0.9rem;
  }
  
  .tooltip-type {
    font-size: 0.8rem;
    color: #aaa;
    margin-bottom: 0.4rem;
  }
  
  .tooltip-description {
    font-size: 0.8rem;
    line-height: 1.3;
    color: #ccc;
    padding-bottom: 0.4rem;
  }
  
  /* Item details - Better styling */
  .item-details {
    background-color: rgba(20, 20, 20, 0.6);
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
  }
  
  .item-detail-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }
  
  .item-detail-header h4 {
    margin: 0;
    color: var(--toxic-green);
    font-size: 18px;
  }
  
  .item-description {
    margin-bottom: 15px;
    line-height: 1.4;
    color: #ddd;
    font-size: 14px;
    padding: 0 5px;
  }
  
  .item-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 15px;
    padding: 10px;
    background-color: rgba(20, 20, 20, 0.5);
    border-radius: 5px;
    border: 1px solid rgba(100, 100, 100, 0.3);
  }
  
  .item-stat {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: rgba(30, 30, 30, 0.8);
    padding: 8px 10px;
    border-radius: 3px;
  }
  
  .stat-name {
    color: #888;
    font-size: 13px;
  }
  
  .stat-value {
    color: #fff;
    font-weight: bold;
    font-size: 13px;
  }
  
  /* Item actions */
  .item-actions {
    margin-top: 1.5rem;
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.5rem;
  }
  
  .danger-button {
    border-color: var(--health-red);
    color: var(--health-red);
  }
  
  .danger-button:hover {
    box-shadow: 0 0 15px rgba(255, 51, 51, 0.7);
    background-color: rgba(255, 51, 51, 0.1);
  }
  
  /* Footer */
  .inventory-footer {
    margin-top: 2rem;
    text-align: center;
  }
  
  /* Responsive styles */
  @media (max-width: 992px) {
    .inventory-sections {
      grid-template-columns: 1fr;
    }
    
    .equipment-section {
      grid-row: auto;
    }
    
    .equipment-slots {
      grid-template-areas:
        "head weapon accessory"
        "body hands legs"
        "feet . .";
    }
  }
  
  @media (max-width: 768px) {
    .inventory-grid {
      grid-template-columns: repeat(4, 1fr);
    }
  }
  
  @media (max-width: 576px) {
    .inventory-grid {
      grid-template-columns: repeat(3, 1fr);
    }
    
    .equipment-slots {
      grid-template-areas:
        "head body"
        "hands legs"
        "feet weapon"
        "accessory .";
    }
  }
  
  #debug-info {
    margin-top: 20px;
    padding: 10px;
    background-color: #333;
    border: 1px solid #666;
    border-radius: 5px;
  }
  #debug-info h3 {
    color: #ff5722;
    margin-top: 0;
  }
  #debug-content p {
    margin: 5px 0;
    font-family: monospace;
    font-size: 12px;
  }
  .error-message {
    color: #ff5722;
    text-align: center;
    padding: 20px;
  }
  
  /* Toast notifications */
  .toast {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: rgba(10, 10, 10, 0.9);
    color: #fff;
    padding: 15px;
    border-radius: 5px;
    border-left: 4px solid var(--toxic-green);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    z-index: 9999;
    max-width: 300px;
    opacity: 0;
    transform: translateX(50px);
    transition: all 0.3s ease;
  }
  
  .toast.show {
    opacity: 1;
    transform: translateX(0);
  }
  
  .toast-effects {
    margin-top: 5px;
    font-size: 0.9rem;
    color: #aaa;
  }
</style> 