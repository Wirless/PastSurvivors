<div class="container scavenge-container">
  <div class="scavenge-header">
    <h2 class="glitch-text">Scavenging</h2>
    <p class="subtitle">Find resources and encounter dangers in the wasteland</p>
  </div>

  <!-- Character status bar -->
  <div class="character-status-container" id="character-status-container">
    <div class="status-bar">
      <div class="status-item health-status">
        <span class="status-label">Health:</span>
        <div class="status-bar-container">
          <div class="status-bar-wrapper">
            <div class="status-bar-fill health-bar-fill" id="character-health-bar"></div>
          </div>
          <div class="status-value" id="character-health-value">0/0</div>
        </div>
      </div>
      <div class="status-item energy-status">
        <span class="status-label">Energy:</span>
        <div class="status-bar-container">
          <div class="status-bar-wrapper">
            <div class="status-bar-fill energy-bar-fill" id="character-energy-bar"></div>
          </div>
          <div class="status-value" id="character-energy-value">0/0</div>
        </div>
      </div>
      <div class="status-item recovery-status hidden" id="recovery-status">
        <span class="status-label">Recovery:</span>
        <div class="recovery-time" id="recovery-time">10:00</div>
      </div>
    </div>
  </div>

  <div class="scavenge-content">
    <!-- Move combat window before the locations section for better readability -->
    <div class="combat-window hidden" id="combat-window">
      <h3>Combat Encounter</h3>
      <div class="combat-status-indicator" id="combat-status-indicator">
        <div class="combat-pause-message">Scavenging paused during combat</div>
      </div>
      <div class="combat-arena">
        <div class="combat-entity player-entity">
          <div class="entity-image" id="player-image">
            <img src="/images/player/default-player.png" alt="Player">
          </div>
          <div class="entity-info">
            <div class="entity-name" id="player-name">Player</div>
            <div class="health-bar-container">
              <div class="health-bar-label">HP:</div>
              <div class="health-bar-wrapper">
                <div class="health-bar player-health-bar" id="combat-player-health-bar"></div>
              </div>
              <div class="health-value" id="combat-player-health-value">0/0</div>
            </div>
          </div>
        </div>
        
        <div class="combat-vs">VS</div>
        
        <div class="combat-entity monster-entity">
          <div class="entity-image" id="monster-image">
            <!-- Monster image will be displayed here -->
          </div>
          <div class="entity-info">
            <div class="entity-name" id="combat-monster-name">Monster</div>
            <div class="health-bar-container">
              <div class="health-bar-label">HP:</div>
              <div class="health-bar-wrapper">
                <div class="health-bar monster-health-bar" id="combat-monster-health-bar"></div>
              </div>
              <div class="health-value" id="combat-monster-health-value">0/0</div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="combat-details">
        <div class="monster-details">
          <div class="monster-stats">
            <div class="monster-stat">
              <span class="stat-label">Damage:</span>
              <span class="stat-value" id="combat-monster-damage">0</span>
            </div>
            <div class="monster-stat">
              <span class="stat-label">XP Value:</span>
              <span class="stat-value" id="combat-monster-xp">0</span>
            </div>
          </div>
        </div>
        
        <div class="combat-info">
          <div class="combat-round">Round: <span id="combat-round-count">0</span></div>
          <div class="combat-damage-info">
            <div class="damage-dealt">Your damage: <span id="combat-player-damage">0</span></div>
            <div class="damage-received">Monster damage: <span id="combat-monster-damage-dealt">0</span></div>
          </div>
          <div class="combat-timer">Next round in: <span id="combat-round-timer">2s</span></div>
        </div>
      </div>
      
      <div class="combat-log-container">
        <h4>Combat Log</h4>
        <div class="combat-log" id="combat-log">
          <!-- Combat logs will be added here -->
        </div>
      </div>
      
      <div class="combat-recovery hidden" id="combat-recovery">
        <div class="recovery-message">You were defeated! Recovering...</div>
        <div class="recovery-progress-container">
          <div class="recovery-progress" id="recovery-progress"></div>
        </div>
        <div class="recovery-time" id="recovery-time">10:00</div>
      </div>
    </div>

    <div class="locations-section" id="locations-section">
      <h3>Select Location</h3>
      <div class="location-carousel">
        <button class="carousel-btn prev-btn" id="prev-location-btn">&laquo;</button>
        <div class="carousel-container" id="location-carousel">
          <!-- Locations will be populated here via JavaScript -->
          <div class="loading-indicator">Loading locations...</div>
        </div>
        <button class="carousel-btn next-btn" id="next-location-btn">&raquo;</button>
      </div>
      <div class="location-details" id="location-details">
        <div class="location-description">Select a location to view details</div>
        <div class="location-stats"></div>
        <button class="action-button glow-button" id="start-scavenge-btn" disabled>Start Scavenging</button>
      </div>
    </div>

    <div class="active-scavenge-section hidden" id="active-scavenge-section">
      <h3>Currently Scavenging</h3>
      <div class="active-location-info" id="active-location-info">
        <!-- Active location info will be shown here -->
      </div>
      <div class="scavenge-progress">
        <div class="scavenge-header-info">
          <div class="elapsed-time-container">
            <span class="elapsed-label">Time elapsed:</span>
            <span class="elapsed-value" id="elapsed-time">0:00</span>
          </div>
          <div class="next-event-container">
            <span class="next-event-label">Next event:</span>
            <div class="next-event-progress-container">
              <div class="next-event-progress" id="next-event-progress"></div>
            </div>
          </div>
        </div>
        
        <div class="scavenge-log-container">
          <h4>Scavenge Log</h4>
          <div class="scavenge-log" id="scavenge-log">
            <!-- Scavenge logs will be added here -->
          </div>
        </div>
        <div class="scavenge-loot-container">
          <h4>Loot Found</h4>
          <div class="scavenge-loot" id="scavenge-loot">
            <!-- Loot will be added here -->
          </div>
        </div>
        <button class="action-button danger-button" id="end-scavenge-btn">End Scavenging</button>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
  // Elements
  const locationCarousel = document.getElementById('location-carousel');
  const locationDetails = document.getElementById('location-details');
  const prevBtn = document.getElementById('prev-location-btn');
  const nextBtn = document.getElementById('next-location-btn');
  const startScavengeBtn = document.getElementById('start-scavenge-btn');
  const endScavengeBtn = document.getElementById('end-scavenge-btn');
  const locationsSection = document.getElementById('locations-section');
  const activeScavengeSection = document.getElementById('active-scavenge-section');
  const activeLocationInfo = document.getElementById('active-location-info');
  const scavengeLog = document.getElementById('scavenge-log');
  const scavengeLoot = document.getElementById('scavenge-loot');
  const elapsedTimeDisplay = document.getElementById('elapsed-time');
  
  // Character status elements
  const characterHealthBar = document.getElementById('character-health-bar');
  const characterHealthValue = document.getElementById('character-health-value');
  const characterEnergyBar = document.getElementById('character-energy-bar');
  const characterEnergyValue = document.getElementById('character-energy-value');
  const recoveryStatusElement = document.getElementById('recovery-status');
  const recoveryTimeElement = document.getElementById('recovery-time');
  
  // Combat elements
  const combatWindow = document.getElementById('combat-window');
  const combatPlayerHealthBar = document.getElementById('combat-player-health-bar');
  const combatPlayerHealthValue = document.getElementById('combat-player-health-value');
  const combatMonsterHealthBar = document.getElementById('combat-monster-health-bar');
  const combatMonsterHealthValue = document.getElementById('combat-monster-health-value');
  const combatMonsterName = document.getElementById('combat-monster-name');
  const combatMonsterDamage = document.getElementById('combat-monster-damage');
  const combatMonsterXP = document.getElementById('combat-monster-xp');
  const combatRoundCount = document.getElementById('combat-round-count');
  const combatPlayerDamage = document.getElementById('combat-player-damage');
  const combatMonsterDamageDealt = document.getElementById('combat-monster-damage-dealt');
  const combatRoundTimer = document.getElementById('combat-round-timer');
  const combatLogContainer = document.getElementById('combat-log');
  const playerName = document.getElementById('player-name');
  const monsterImage = document.getElementById('monster-image');
  const combatRecoverySection = document.getElementById('combat-recovery');
  const recoveryProgress = document.getElementById('recovery-progress');
  
  // State
  let locations = [];
  let currentLocationIndex = 0;
  let isScavenging = false;
  let isInCombat = false;
  let scavengeStartTime = null;
  let scavengeIntervalId = null;
  let statusCheckIntervalId = null;
  let characterStatusIntervalId = null;
  let recoveryEndTime = null;
  let recoveryIntervalId = null;
  let combatIntervalId = null; // Separate interval for combat updates
  
  // Load locations
  try {
    const response = await fetch('/api/scavenge/locations');
    const data = await response.json();
    
    if (data.success && data.data.locations) {
      locations = data.data.locations;
      renderLocationCarousel();
      updateLocationDetails();
    } else {
      locationCarousel.innerHTML = '<div class="error-message">Failed to load locations</div>';
    }
  } catch (error) {
    console.error('Error loading locations:', error);
    locationCarousel.innerHTML = '<div class="error-message">Error loading locations</div>';
  }
  
  // Load initial character status
  await updateCharacterStatus();
  
  // Start character status update interval
  characterStatusIntervalId = setInterval(updateCharacterStatus, 5000);
  
  // Check if already scavenging
  checkScavengeStatus();
  
  // Event listeners
  prevBtn.addEventListener('click', () => {
    if (currentLocationIndex > 0) {
      currentLocationIndex--;
      updateLocationDetails();
    }
  });
  
  nextBtn.addEventListener('click', () => {
    if (currentLocationIndex < locations.length - 1) {
      currentLocationIndex++;
      updateLocationDetails();
    }
  });
  
  startScavengeBtn.addEventListener('click', startScavenging);
  endScavengeBtn.addEventListener('click', endScavenging);
  
  // Functions
  function renderLocationCarousel() {
    if (locations.length === 0) {
      locationCarousel.innerHTML = '<div class="error-message">No locations available</div>';
      return;
    }
    
    locationCarousel.innerHTML = '';
    
    locations.forEach((location, index) => {
      const locationCard = document.createElement('div');
      locationCard.className = `location-card ${index === currentLocationIndex ? 'active' : ''}`;
      locationCard.dataset.index = index;
      
      locationCard.innerHTML = `
        <div class="location-image">
          <img src="${location.image}" alt="${location.name}">
        </div>
        <div class="location-name">${location.name}</div>
      `;
      
      locationCard.addEventListener('click', () => {
        document.querySelectorAll('.location-card').forEach(card => {
          card.classList.remove('active');
        });
        locationCard.classList.add('active');
        currentLocationIndex = index;
        updateLocationDetails();
      });
      
      locationCarousel.appendChild(locationCard);
    });
  }
  
  function updateLocationDetails() {
    if (locations.length === 0) return;
    
    const location = locations[currentLocationIndex];
    
    // Update carousel active card
    document.querySelectorAll('.location-card').forEach((card, index) => {
      if (index === currentLocationIndex) {
        card.classList.add('active');
      } else {
        card.classList.remove('active');
      }
    });
    
    // Update location details
    locationDetails.innerHTML = `
      <div class="location-name">${location.name}</div>
      <div class="location-description">${location.description}</div>
      <div class="location-info-container">
        <div class="location-stats">
          <div class="location-stat">
            <span class="stat-label">Energy Cost:</span>
            <span class="stat-value">${location.energy_cost}</span>
          </div>
          <div class="location-stat">
            <span class="stat-label">Required Level:</span>
            <span class="stat-value">${location.min_level || 1}</span>
          </div>
          <div class="location-difficulty">
            <span class="difficulty-label">Difficulty:</span>
            <span class="difficulty-value">${getDifficultyLabel(location)}</span>
          </div>
        </div>
      </div>
      <button class="action-button glow-button" id="start-scavenge-btn">Start Scavenging</button>
    `;
    
    // Re-attach event listener to the new button
    document.getElementById('start-scavenge-btn').addEventListener('click', startScavenging);
    
    // Update prev/next buttons
    prevBtn.disabled = currentLocationIndex === 0;
    nextBtn.disabled = currentLocationIndex === locations.length - 1;
  }
  
  // Helper function to get difficulty label based on location properties
  function getDifficultyLabel(location) {
    const minLevel = location.min_level || 1;
    
    if (minLevel >= 10) {
      return '<span class="difficulty-extreme">Extreme</span>';
    } else if (minLevel >= 7) {
      return '<span class="difficulty-hard">Hard</span>';
    } else if (minLevel >= 4) {
      return '<span class="difficulty-medium">Medium</span>';
    } else {
      return '<span class="difficulty-easy">Easy</span>';
    }
  }
  
  async function startScavenging() {
    if (locations.length === 0) return;
    
    const location = locations[currentLocationIndex];
    
    try {
      // First check if character is in recovery
      const characterResponse = await fetch('/api/character');
      const characterData = await characterResponse.json();
      
      if (characterData.success && characterData.data) {
        const character = characterData.data;
        
        // Check if in recovery
        if (character.recoveryUntil) {
          const recoveryDate = new Date(character.recoveryUntil);
          if (recoveryDate > new Date()) {
            const minutesLeft = Math.ceil((recoveryDate - new Date()) / (1000 * 60));
            alert(`You cannot scavenge while recovering from injuries. Recovery ends in ${minutesLeft} minutes.`);
            return;
          }
        }
        
        // We no longer check energy requirements as they are removed
      }
      
      const response = await fetch(`/api/scavenge/start/${location.id}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      const data = await response.json();
      
      if (data.success) {
        // Switch to active scavenging view
        isScavenging = true;
        scavengeStartTime = Date.now();
        
        // Show active section, hide location selection
        locationsSection.classList.add('hidden');
        activeScavengeSection.classList.remove('hidden');
        
        // Hide combat window if visible
        if (combatWindow) {
          combatWindow.classList.add('hidden');
        }
        
        // Display location info
        activeLocationInfo.innerHTML = `
          <div class="active-location-header">
            <div class="active-location-image">
              <img src="${location.image}" alt="${location.name}">
            </div>
            <div class="active-location-details">
              <h4>${location.name}</h4>
              <p>${location.description}</p>
            </div>
          </div>
        `;
        
        // Start timer and periodic status checks
        startScavengeTimer();
        
        // Start polling for updates
        startPollingForUpdates();
        
        // Add initial log entry
        addLogEntry(data.data.message || `Started scavenging at ${location.name}`);
      } else {
        if (data.recovery) {
          alert(`You cannot scavenge while recovering from injuries. Recovery ends in ${data.recovery.minutesLeft} minutes.`);
        } else {
          alert(data.message || 'Failed to start scavenging');
        }
      }
    } catch (error) {
      console.error('Error starting scavenge:', error);
      alert('Error starting scavenging session');
    }
  }
  
  async function endScavenging() {
    try {
      const response = await fetch('/api/scavenge/end', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      const data = await response.json();
      
      if (data.success) {
        // Clear intervals
        clearInterval(scavengeIntervalId);
        clearInterval(statusCheckIntervalId);
        
        // Continue character status updates
        if (!characterStatusIntervalId) {
          characterStatusIntervalId = setInterval(updateCharacterStatus, 5000);
        }
        
        // Update character status immediately to reflect changes
        await updateCharacterStatus();
        
        // Show results summary
        const results = data.data.results;
        
        // Add a summary message to the log
        const experienceGained = results.experienceGained || 0;
        const lootCount = results.loot ? results.loot.length : 0;
        
        addLogEntry(`Scavenging session ended. Gained ${experienceGained} experience and found ${lootCount} items.`);
        
        // Update UI to show session ended
        endScavengeBtn.disabled = true;
        endScavengeBtn.textContent = 'Session Ended';
        
        // Add a button to return to location selection
        const returnBtn = document.createElement('button');
        returnBtn.className = 'action-button glow-button';
        returnBtn.textContent = 'Return to Locations';
        returnBtn.addEventListener('click', () => {
          activeScavengeSection.classList.add('hidden');
          locationsSection.classList.remove('hidden');
          isScavenging = false;
          checkScavengeStatus();  // Refresh status
        });
        
        // Add the button after the end button
        endScavengeBtn.parentNode.appendChild(returnBtn);
      } else {
        alert(data.message || 'Failed to end scavenging session');
      }
    } catch (error) {
      console.error('Error ending scavenge:', error);
      alert('Error ending scavenging session');
    }
  }
  
  function startScavengeTimer() {
    scavengeIntervalId = setInterval(() => {
      if (!scavengeStartTime) return;
      
      const elapsed = Date.now() - scavengeStartTime;
      const minutes = Math.floor(elapsed / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      
      elapsedTimeDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
  }
  
  async function checkScavengeStatus() {
    try {
      const response = await fetch('/api/scavenge/status');
      const data = await response.json();
      
      if (data.success) {
        if (data.data.active) {
          // There's an active scavenging session
          if (!isScavenging) {
            // We just discovered an active session
            isScavenging = true;
            
            // Show active section, hide location selection
            locationsSection.classList.add('hidden');
            activeScavengeSection.classList.remove('hidden');
            
            // Find the location in our list
            const location = locations.find(loc => loc.id === data.data.locationId) || {
              name: 'Unknown Location',
              description: 'Details unavailable',
              image: '/images/location-default.jpg'
            };
            
            // Display location info
            activeLocationInfo.innerHTML = `
              <div class="active-location-header">
                <div class="active-location-image">
                  <img src="${location.image}" alt="${location.name}">
                </div>
                <div class="active-location-details">
                  <h4>${location.name}</h4>
                  <p>${location.description}</p>
                </div>
              </div>
            `;
            
            // Set start time
            scavengeStartTime = data.data.startTime;
            
            // Start timer
            startScavengeTimer();
            
            // Start polling for updates
            startPollingForUpdates();
            
            // Update the log and loot
            updateScavengeLogs(data.data.logs);
            updateScavengeLoot(data.data.loot);
          } else {
            // Update log if not in combat
            if (!isInCombat && data.data.logs && data.data.logs.length > 0) {
              updateScavengeLogs(data.data.logs);
            }
            
            // Update loot if not in combat
            if (!isInCombat && data.data.loot) {
              updateScavengeLoot(data.data.loot);
            }
          }
          
          // Handle combat in a separate flow
          handleCombatState(data.data);
          
          // Update next event countdown if not in combat
          if (data.data.nextEventIn !== null && !isInCombat) {
            updateNextEventCountdown(data.data.nextEventIn);
          }
          
          // Check if player is in recovery
          if (data.data.character && data.data.character.recoveryUntil) {
            const recoveryDate = new Date(data.data.character.recoveryUntil);
            if (recoveryDate > new Date()) {
              startRecoveryCountdown(recoveryDate);
            } else {
              stopRecoveryCountdown();
            }
          }
        } else if (isScavenging) {
          // Was scavenging but now it's over
          isScavenging = false;
          isInCombat = false;
          
          // Stop all timers and status checks
          clearInterval(scavengeIntervalId);
          clearInterval(statusCheckIntervalId);
          clearInterval(combatIntervalId);
          
          // Reset UI
          showResultsView();
        }
      }
    } catch (error) {
      console.error('Error checking scavenge status:', error);
    }
  }
  
  // New function to handle combat state separately
  function handleCombatState(data) {
    // Ensure we have valid combat data before proceeding
    if (!data) return;
    
    // Check for combat state changes
    if (data.currentCombat && data.currentCombat.monster && !isInCombat) {
      // New combat started
      isInCombat = true;
      
      // Stop scavenge polling to prevent interference
      if (statusCheckIntervalId) {
        clearInterval(statusCheckIntervalId);
        statusCheckIntervalId = null;
      }
      
      // Start combat
      startCombat(data.currentCombat, data.character);
      
      // Start a separate combat status check
      if (!combatIntervalId) {
        // Use a more frequent interval for combat (every 1 second)
        combatIntervalId = setInterval(updateCombatStatus, 1000);
      }
    } 
    // Combat ended
    else if (!data.currentCombat && isInCombat) {
      isInCombat = false;
      endCombat(data.character);
      
      // Clear combat interval
      if (combatIntervalId) {
        clearInterval(combatIntervalId);
        combatIntervalId = null;
      }
      
      // Restart scavenge polling
      startPollingForUpdates();
    }
  }
  
  // New function to update combat status independently
  async function updateCombatStatus() {
    if (!isInCombat) {
      if (combatIntervalId) {
        clearInterval(combatIntervalId);
        combatIntervalId = null;
      }
      return;
    }
    
    try {
      // Only use the regular status endpoint since we don't have a combat-specific one
      const response = await fetch('/api/scavenge/status');
      const data = await response.json();
      
      if (data.success) {
        // Check if combat is still active
        if (data.data.currentCombat && data.data.currentCombat.monster) {
          // Get character health data (from either path in the response)
          const character = data.data.character || 
                           data.data.characterHealth || 
                           { health: { current: 0, max: 100 } }; // Fallback
          
          // Update the combat display - don't update scavenging log
          updateCombatDisplay(data.data.currentCombat, character);
          
          // Disable scavenging log updates during combat to prevent duplicate entries
          if (statusCheckIntervalId) {
            clearInterval(statusCheckIntervalId);
            statusCheckIntervalId = null;
          }
        } else {
          // Combat ended on server
          isInCombat = false;
          endCombat(data.data.character);
          
          // Clear interval
          if (combatIntervalId) {
            clearInterval(combatIntervalId);
            combatIntervalId = null;
          }
          
          // Restart scavenging updates
          startPollingForUpdates();
        }
      }
    } catch (error) {
      console.error('Error updating combat status:', error);
      
      // If we reach this point, something is seriously wrong
      // Add a failsafe to prevent locking the UI
      if (error.message && error.message.includes('combat')) {
        console.log('Recovering from combat error...');
        
        // Try to gracefully recover by ending combat mode
        isInCombat = false;
        
        // Clear interval
        if (combatIntervalId) {
          clearInterval(combatIntervalId);
          combatIntervalId = null;
        }
        
        // Restart scavenging updates
        startPollingForUpdates();
        
        // Show error message in the combat log if available
        if (combatLogContainer) {
          addCombatLogEntry('Error in combat system. Returning to scavenging...');
        }
      }
    }
  }
  
  function updateScavengeLogs(logs) {
    if (!logs || !logs.length) return;
    
    // Clear existing logs and add all new ones
    scavengeLog.innerHTML = '';
    
    // Filter out combat logs if in combat
    const filteredLogs = isInCombat 
      ? logs.filter(log => !log.message.includes('attacks you') && !log.message.includes('You attack') && !log.message.includes('defeated'))
      : logs;
    
    filteredLogs.forEach(log => {
      const logTime = new Date(log.time);
      const timeString = `${logTime.getHours().toString().padStart(2, '0')}:${logTime.getMinutes().toString().padStart(2, '0')}`;
      
      const logEntry = document.createElement('div');
      logEntry.className = 'log-entry';
      logEntry.innerHTML = `
        <span class="log-time">[${timeString}]</span>
        <span class="log-message">${log.message}</span>
      `;
      
      scavengeLog.appendChild(logEntry);
    });
    
    // Scroll to bottom
    scavengeLog.scrollTop = scavengeLog.scrollHeight;
  }
  
  function updateScavengeLoot(loot) {
    if (!loot || !loot.length) {
      scavengeLoot.innerHTML = '<div class="no-loot">No items found yet</div>';
      return;
    }
    
    // Clear existing loot and add all new ones
    scavengeLoot.innerHTML = '';
    
    loot.forEach(item => {
      const lootEntry = document.createElement('div');
      lootEntry.className = 'loot-entry';
      lootEntry.innerHTML = `
        <span class="loot-name">${item.item_id.replace(/_/g, ' ')}</span>
        <span class="loot-quantity">x${item.quantity || 1}</span>
      `;
      
      scavengeLoot.appendChild(lootEntry);
    });
  }
  
  function addLogEntry(message) {
    const now = new Date();
    const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    logEntry.innerHTML = `
      <span class="log-time">[${timeString}]</span>
      <span class="log-message">${message}</span>
    `;
    
    scavengeLog.appendChild(logEntry);
    scavengeLog.scrollTop = scavengeLog.scrollHeight;
  }
  
  // Update the next event countdown to use a progress bar instead of text
  function updateNextEventCountdown(seconds) {
    const progressBar = document.getElementById('next-event-progress');
    const progressContainer = document.querySelector('.next-event-container');
    
    if (!progressBar || !progressContainer) return;
    
    if (seconds <= 0) {
      progressBar.style.width = '100%';
      progressContainer.classList.add('event-imminent');
    } else {
      // Get the max time between events (we know it's between 15-60 seconds from the controller)
      const maxTime = 60;
      // Calculate progress percentage (inverted - starts full and decreases)
      const progressPercent = 100 - ((seconds / maxTime) * 100);
      progressBar.style.width = `${progressPercent}%`;
      progressContainer.classList.remove('event-imminent');
    }
  }
  
  // Increase status check frequency to update countdown more often
  function startPollingForUpdates() {
    // Clear any existing interval
    if (statusCheckIntervalId) {
      clearInterval(statusCheckIntervalId);
    }
    
    // Set more frequent polling (every 2 seconds) for general scavenging updates
    statusCheckIntervalId = setInterval(async () => {
      // Only check general scavenging status if not in combat
      // This prevents interference between combat and scavenging updates
      if (!isInCombat) {
        await checkScavengeStatus();
      }
      
      // Always update character status
      await updateCharacterStatus();
    }, 2000);
  }

  // Add the missing showResultsView function
  function showResultsView() {
    // Clear any existing intervals
    clearInterval(scavengeIntervalId);
    clearInterval(statusCheckIntervalId);
    
    // Fetch the final results
    fetch('/api/scavenge/end', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        // Update the UI with results
        const results = data.data.results;
        
        // Create results view
        const resultsContainer = document.createElement('div');
        resultsContainer.className = 'scavenge-results-container';
        
        // Format duration
        const minutes = Math.floor(results.duration / 60);
        const seconds = results.duration % 60;
        const durationText = `${minutes}m ${seconds}s`;
        
        // Format results
        resultsContainer.innerHTML = `
          <h3>Scavenging Results</h3>
          <div class="results-summary">
            <div class="result-item">
              <span class="result-label">Duration:</span>
              <span class="result-value">${durationText}</span>
            </div>
            <div class="result-item">
              <span class="result-label">Experience Gained:</span>
              <span class="result-value">${results.experienceGained || 0}</span>
            </div>
            <div class="result-item">
              <span class="result-label">Items Found:</span>
              <span class="result-value">${results.loot ? results.loot.length : 0}</span>
            </div>
          </div>
          
          <div class="results-sections">
            <div class="results-section">
              <h4>Scavenge Log</h4>
              <div class="results-log">
                ${results.logs.map(log => `<div class="log-entry">${log.message}</div>`).join('')}
              </div>
            </div>
            
            <div class="results-section">
              <h4>Items Added to Inventory</h4>
              <div class="results-items">
                ${results.itemsAdded && results.itemsAdded.length > 0 ? 
                  results.itemsAdded.map(item => `
                    <div class="result-item-card">
                      <img src="${item.image ? item.image.replace('/images/items/', '') : '/images/items/default-item.png'}" alt="${item.name}" class="item-image">
                      <div class="item-info">
                        <div class="item-name">${item.name}</div>
                        <div class="item-quantity">x${item.quantity}</div>
                      </div>
                    </div>
                  `).join('') : 
                  '<div class="empty-message">No items were added to inventory</div>'
                }
              </div>
            </div>
          </div>
          
          <div class="results-actions">
            <button class="action-button glow-button" id="back-to-locations-btn">Back to Locations</button>
          </div>
        `;
        
        // Replace the active scavenge section with results
        activeScavengeSection.innerHTML = '';
        activeScavengeSection.appendChild(resultsContainer);
        
        // Add event listener to the back button
        document.getElementById('back-to-locations-btn').addEventListener('click', () => {
          // Reset UI
          activeScavengeSection.classList.add('hidden');
          locationsSection.classList.remove('hidden');
          
          // Reload the page to reset everything
          window.location.reload();
        });
      } else {
        alert(data.message || 'Failed to get scavenging results');
        
        // Reset UI
        activeScavengeSection.classList.add('hidden');
        locationsSection.classList.remove('hidden');
      }
    })
    .catch(error => {
      console.error('Error ending scavenge:', error);
      alert('Error loading scavenging results');
      
      // Reset UI
      activeScavengeSection.classList.add('hidden');
      locationsSection.classList.remove('hidden');
    });
  }

  async function updateCharacterStatus() {
    try {
      const response = await fetch('/api/character');
      const data = await response.json();
      
      if (data.success && data.data) {
        const character = data.data;
        
        // Update health
        const healthPercent = (character.health.current / character.health.max) * 100;
        characterHealthBar.style.width = `${Math.max(0, Math.min(100, healthPercent))}%`;
        characterHealthValue.textContent = `${character.health.current}/${character.health.max}`;
        
        // Update energy
        const energyPercent = (character.energy.current / character.energy.max) * 100;
        characterEnergyBar.style.width = `${Math.max(0, Math.min(100, energyPercent))}%`;
        characterEnergyValue.textContent = `${character.energy.current}/${character.energy.max}`;
        
        // Check recovery status
        if (character.recoveryUntil) {
          const recoveryDate = new Date(character.recoveryUntil);
          const now = new Date();
          
          if (recoveryDate > now) {
            const timeDiff = recoveryDate - now;
            const minutesLeft = Math.floor(timeDiff / 60000);
            const secondsLeft = Math.floor((timeDiff % 60000) / 1000);
            
            recoveryStatusElement.classList.remove('hidden');
            recoveryTimeElement.textContent = `${minutesLeft}:${secondsLeft.toString().padStart(2, '0')}`;
            
            // Disable start button if on location selection screen
            if (startScavengeBtn) {
              startScavengeBtn.disabled = true;
              startScavengeBtn.classList.add('disabled-action');
              startScavengeBtn.title = `You cannot scavenge while recovering. Recovery ends in ${minutesLeft}:${secondsLeft.toString().padStart(2, '0')}`;
            }
          } else {
            recoveryStatusElement.classList.add('hidden');
            
            // Enable start button
            if (startScavengeBtn) {
              startScavengeBtn.disabled = false;
              startScavengeBtn.classList.remove('disabled-action');
              startScavengeBtn.title = '';
            }
          }
        } else {
          recoveryStatusElement.classList.add('hidden');
          
          // Enable start button
          if (startScavengeBtn) {
            startScavengeBtn.disabled = false;
            startScavengeBtn.classList.remove('disabled-action');
            startScavengeBtn.title = '';
          }
        }
      }
    } catch (error) {
      console.error('Error updating character status:', error);
    }
  }

  // Start combat mode
  function startCombat(combat, character) {
    if (!combatWindow || !combat || !combat.monster) return;
    
    // Ensure we pause the scavenging updates
    if (statusCheckIntervalId) {
      clearInterval(statusCheckIntervalId);
      statusCheckIntervalId = null;
    }
    
    // Show combat window with higher z-index
    combatWindow.classList.remove('hidden');
    combatWindow.style.zIndex = "100"; // Ensure it's on top
    
    // Set player name from character data
    if (playerName) {
      playerName.textContent = character?.name || 'Player';
    }
    
    // Clear combat log
    if (combatLogContainer) {
      combatLogContainer.innerHTML = '';
    }
    
    // Add a flashing effect to the combat window
    combatWindow.classList.add('combat-flash');
    setTimeout(() => {
      combatWindow.classList.remove('combat-flash');
    }, 500);
    
    // Add initial combat log entry
    addCombatLogEntry(`Combat started! You encounter a ${combat.monster.name}!`);
    
    // Scroll to combat window with smooth animation
    combatWindow.scrollIntoView({ behavior: 'smooth', block: 'start' });
    
    // Update the combat display with character data
    updateCombatDisplay(combat, character);
  }
  
  // End combat
  function endCombat(character) {
    if (!combatWindow) return;
    
    // Add final combat log entry
    addCombatLogEntry('Combat ended!');
    
    // Reset combat status
    isInCombat = false;
    
    // Clear any combat interval
    if (combatIntervalId) {
      clearInterval(combatIntervalId);
      combatIntervalId = null;
    }
    
    // After a short delay, hide the combat window
    setTimeout(() => {
      combatWindow.classList.add('hidden');
      
      // Clear combat log
      if (combatLogContainer) {
        combatLogContainer.innerHTML = '';
      }
      
      // Restart scavenging polling if we're still scavenging
      if (isScavenging) {
        startPollingForUpdates();
      }
    }, 2000);
    
    // Check if player died and needs recovery
    if (character && character.recoveryUntil) {
      const recoveryDate = new Date(character.recoveryUntil);
      if (recoveryDate > new Date()) {
        startRecoveryCountdown(recoveryDate);
      }
    }
    
    // Update character status
    updateCharacterStatus();
  }
  
  // Update combat display
  function updateCombatDisplay(combat, character) {
    if (!combatWindow || !combat || !combat.monster) return;
    
    const monster = combat.monster;
    
    // Update monster image
    if (monsterImage) {
      if (monster.image) {
        monsterImage.innerHTML = `<img src="${monster.image}" alt="${monster.name}">`;
      } else {
        monsterImage.innerHTML = `<div class="monster-placeholder">${monster.name}</div>`;
      }
    }
    
    // Update monster name and stats
    if (combatMonsterName) combatMonsterName.textContent = monster.name;
    if (combatMonsterDamage) combatMonsterDamage.textContent = monster.damage || 0;
    if (combatMonsterXP) combatMonsterXP.textContent = monster.experience || 0;
    
    // Update monster health
    if (combatMonsterHealthBar && combatMonsterHealthValue) {
      const monsterHealthPercent = (monster.currentHealth / monster.health) * 100;
      combatMonsterHealthBar.style.width = `${Math.max(0, Math.min(100, monsterHealthPercent))}%`;
      combatMonsterHealthValue.textContent = `${monster.currentHealth}/${monster.health}`;
    }
    
    // Update player health using both combat-specific and global health bars
    // This ensures we always show health consistently
    if (character) {
      // First try to extract health values regardless of data structure
      let current, max;
      
      if (character.health && typeof character.health === 'object') {
        // Health is in a nested object (preferred)
        current = character.health.current;
        max = character.health.max;
      } else if (character.current !== undefined && character.max !== undefined) {
        // Health is directly on the character
        current = character.current;
        max = character.max;
      } else {
        // Fallback values if nothing else works
        // This prevents "cannot read property of undefined" errors
        current = 0;
        max = 100;
      }
      
      // Make sure we have valid numbers
      if (typeof current !== 'number') current = 0;
      if (typeof max !== 'number') max = 100;
      
      // Calculate health percentage
      const playerHealthPercent = (current / max) * 100;
      
      // Update combat-specific health bar
      if (combatPlayerHealthBar && combatPlayerHealthValue) {
        combatPlayerHealthBar.style.width = `${Math.max(0, Math.min(100, playerHealthPercent))}%`;
        combatPlayerHealthValue.textContent = `${current}/${max}`;
      }
      
      // Also update the global character health bar to keep them in sync
      if (characterHealthBar && characterHealthValue) {
        characterHealthBar.style.width = `${Math.max(0, Math.min(100, playerHealthPercent))}%`;
        characterHealthValue.textContent = `${current}/${max}`;
      }
    }
    
    // Update combat round and damage info
    if (combatRoundCount) combatRoundCount.textContent = combat.rounds || 0;
    if (combatPlayerDamage) combatPlayerDamage.textContent = combat.playerDamage || 0;
    if (combatMonsterDamageDealt) combatMonsterDamageDealt.textContent = combat.monsterDamage || 0;
    
    // Add combat log entries for new damage if available
    if (combat.newPlayerDamage && combat.newPlayerDamage > 0) {
      addCombatLogEntry(`${monster.name} attacks you for ${combat.newPlayerDamage} damage!`);
    }
    
    if (combat.newMonsterDamage && combat.newMonsterDamage > 0) {
      addCombatLogEntry(`You attack ${monster.name} for ${combat.newMonsterDamage} damage!`);
    }
    
    // Check for combat victory or defeat
    if (monster.currentHealth <= 0) {
      addCombatLogEntry(`You defeated the ${monster.name}!`);
    } else if (character && character.health && character.health.current <= 0) {
      addCombatLogEntry(`You were defeated by the ${monster.name}! Starting recovery...`);
    } else if (character && character.current !== undefined && character.current <= 0) {
      addCombatLogEntry(`You were defeated by the ${monster.name}! Starting recovery...`);
    }
    
    // Update combat timer if present
    if (combatRoundTimer && combat.lastRound) {
      const nextRoundTime = new Date(combat.lastRound + 2000); // 2 seconds after last round
      const timeUntilNextRound = Math.max(0, nextRoundTime - Date.now());
      const secondsLeft = Math.ceil(timeUntilNextRound / 1000);
      combatRoundTimer.textContent = `${secondsLeft}s`;
      
      // Make timer pulse when close to next round
      if (secondsLeft <= 1) {
        combatRoundTimer.classList.add('pulse');
      } else {
        combatRoundTimer.classList.remove('pulse');
      }
    }
  }
  
  // Add combat log entry
  function addCombatLogEntry(message) {
    if (!combatLogContainer) return;
    
    const now = new Date();
    const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
    
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    
    // Apply appropriate classes based on message content
    if (message.includes('defeated') || message.includes('success')) {
      logEntry.classList.add('success');
    } else if (message.includes('attacks you') || message.includes('damage')) {
      logEntry.classList.add('danger');
    }
    
    logEntry.innerHTML = `<span class="log-time">[${timeString}]</span> <span class="log-message">${message}</span>`;
    combatLogContainer.appendChild(logEntry);
    
    // Scroll to the bottom
    combatLogContainer.scrollTop = combatLogContainer.scrollHeight;
  }
  
  // Start recovery countdown after player is defeated
  function startRecoveryCountdown(recoveryEndTime) {
    if (!combatRecoverySection || !recoveryProgress || !recoveryTimeElement) return;
    
    // Show recovery section
    combatRecoverySection.classList.remove('hidden');
    
    // Clear any existing interval
    if (recoveryIntervalId) {
      clearInterval(recoveryIntervalId);
    }
    
    // Update recovery UI function
    const updateRecoveryUI = () => {
      const now = new Date();
      const timeDiff = recoveryEndTime - now;
      
      if (timeDiff <= 0) {
        // Recovery complete
        stopRecoveryCountdown();
        alert('Recovery complete! Your health has been restored to 25 points.');
        return;
      }
      
      // Calculate progress percentage (from 0% to 100%)
      const totalRecoveryTime = 10 * 60 * 1000; // 10 minutes in milliseconds
      const elapsedTime = totalRecoveryTime - timeDiff;
      const progressPercent = (elapsedTime / totalRecoveryTime) * 100;
      
      // Update progress bar
      recoveryProgress.style.width = `${Math.min(100, progressPercent)}%`;
      
      // Update time display
      const minutesLeft = Math.floor(timeDiff / 60000);
      const secondsLeft = Math.floor((timeDiff % 60000) / 1000);
      recoveryTimeElement.textContent = `${minutesLeft}:${secondsLeft.toString().padStart(2, '0')}`;
    };
    
    // Update immediately
    updateRecoveryUI();
    
    // Set interval for updates
    recoveryIntervalId = setInterval(updateRecoveryUI, 1000);
  }
  
  // Stop recovery countdown
  function stopRecoveryCountdown() {
    if (!combatRecoverySection) return;
    
    // Hide recovery section
    combatRecoverySection.classList.add('hidden');
    
    // Clear interval
    if (recoveryIntervalId) {
      clearInterval(recoveryIntervalId);
      recoveryIntervalId = null;
    }
  }
});
</script>

<style>
.scavenge-container {
  max-width: 1000px;
  margin: 0 auto;
  padding: 20px;
}

.scavenge-header {
  text-align: center;
  margin-bottom: 30px;
}

.scavenge-content {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.location-carousel {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
}

.carousel-container {
  display: flex;
  overflow-x: auto;
  scroll-behavior: smooth;
  gap: 15px;
  padding: 10px 0;
  flex-grow: 1;
}

.location-card {
  min-width: 150px;
  height: 180px;
  border-radius: 8px;
  overflow: hidden;
  background-color: #2a2a2a;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  display: flex;
  flex-direction: column;
}

.location-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.location-card.active {
  border: 2px solid #5aff5a;
  transform: translateY(-5px);
  box-shadow: 0 5px 15px rgba(90, 255, 90, 0.3);
}

.location-image {
  height: 120px;
  overflow: hidden;
}

.location-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.location-name {
  padding: 10px;
  text-align: center;
  font-weight: bold;
  color: #ccc;
}

.carousel-btn {
  background-color: #333;
  color: #fff;
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 20px;
  transition: background-color 0.2s;
}

.carousel-btn:hover:not(:disabled) {
  background-color: #444;
}

.carousel-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.location-details {
  background-color: #222;
  padding: 20px;
  border-radius: 8px;
  margin-bottom: 20px;
}

.location-description {
  margin-bottom: 15px;
  color: #aaa;
}

.location-info-container {
  margin: 15px 0 20px;
  background-color: rgba(30, 30, 30, 0.7);
  border: 1px solid #333;
  border-radius: 5px;
  padding: 15px;
}

.location-stats {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 15px;
}

.location-stat, .location-difficulty {
  background-color: rgba(40, 40, 40, 0.7);
  padding: 10px;
  border-radius: 4px;
  position: relative;
  z-index: 1;
}

.stat-label, .difficulty-label {
  display: block;
  font-size: 0.85em;
  color: #aaa;
  margin-bottom: 5px;
}

.stat-value, .difficulty-value {
  font-size: 1.1em;
  color: #fff;
  font-weight: bold;
}

.difficulty-value {
  position: relative;
  padding-right: 20px;
}

.difficulty-easy, .difficulty-medium, .difficulty-hard, .difficulty-extreme {
  position: relative;
  padding-right: 20px;
}

.difficulty-easy:after, .difficulty-medium:after, .difficulty-hard:after, .difficulty-extreme:after {
  content: '';
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 12px;
  height: 12px;
  border-radius: 50%;
}

.difficulty-easy {
  color: #5aff5a;
}

.difficulty-easy:after {
  background-color: #5aff5a;
  box-shadow: 0 0 5px #5aff5a;
}

.difficulty-medium {
  color: #ffff5a;
}

.difficulty-medium:after {
  background-color: #ffff5a;
  box-shadow: 0 0 5px #ffff5a;
}

.difficulty-hard {
  color: #ff9f5a;
}

.difficulty-hard:after {
  background-color: #ff9f5a;
  box-shadow: 0 0 5px #ff9f5a;
}

.difficulty-extreme {
  color: #ff5a5a;
}

.difficulty-extreme:after {
  background-color: #ff5a5a;
  box-shadow: 0 0 5px #ff5a5a;
}

.active-scavenge-section {
  background-color: #222;
  padding: 20px;
  border-radius: 8px;
  position: relative;
  z-index: 2;
}

.active-location-header {
  display: flex;
  gap: 15px;
  margin-bottom: 20px;
}

.active-location-image {
  width: 120px;
  height: 120px;
  border-radius: 8px;
  overflow: hidden;
}

.active-location-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.active-location-details {
  flex-grow: 1;
}

.active-location-details h4 {
  margin-top: 0;
  color: #5aff5a;
}

.scavenge-log-container, .scavenge-loot-container {
  margin-top: 20px;
}

.scavenge-log {
  height: 200px;
  overflow-y: auto;
  border: 1px solid #333;
  padding: 10px;
  background-color: #1a1a1a;
  border-radius: 4px;
  font-family: monospace;
  margin-bottom: 20px;
}

.log-entry {
  margin-bottom: 5px;
  line-height: 1.4;
}

.log-time {
  color: #888;
  margin-right: 5px;
}

.log-message {
  color: #ddd;
}

.scavenge-loot {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 10px;
  margin-top: 10px;
}

.loot-entry {
  background-color: #2a2a2a;
  padding: 8px;
  border-radius: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.loot-name {
  color: #ddd;
  text-transform: capitalize;
}

.loot-quantity {
  color: #5aff5a;
  font-weight: bold;
}

.action-button {
  width: 100%;
  padding: 12px;
  margin-top: 20px;
  font-size: 16px;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.glow-button {
  background-color: #3a3a3a;
  color: #5aff5a;
  border: 1px solid #5aff5a;
  box-shadow: 0 0 5px rgba(90, 255, 90, 0.5);
}

.glow-button:hover {
  background-color: #2a2a2a;
  box-shadow: 0 0 10px rgba(90, 255, 90, 0.7);
}

.danger-button {
  background-color: #3a2a2a;
  color: #ff5a5a;
  border: 1px solid #ff5a5a;
  box-shadow: 0 0 5px rgba(255, 90, 90, 0.5);
}

.danger-button:hover {
  background-color: #2a1a1a;
  box-shadow: 0 0 10px rgba(255, 90, 90, 0.7);
}

.hidden {
  display: none;
}

.error-message {
  color: #ff5a5a;
  text-align: center;
  padding: 10px;
}

.loading-indicator {
  color: #888;
  text-align: center;
  padding: 20px;
}

.no-loot {
  color: #888;
  text-align: center;
  grid-column: 1 / -1;
  padding: 10px;
}

@media (max-width: 768px) {
  .active-location-header {
    flex-direction: column;
  }
  
  .active-location-image {
    width: 100%;
    height: 180px;
  }
}

.scavenge-header-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
  width: 100%;
  gap: 15px;
}

.elapsed-time-container, .next-event-container {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  background-color: rgba(30, 30, 40, 0.7);
  border-radius: 5px;
  border: 1px solid #44475a;
  flex: 1;
  position: relative;
  z-index: 2;
}

.elapsed-label, .next-event-label {
  color: #6272a4;
  font-size: 0.9em;
  white-space: nowrap;
}

.next-event-progress-container {
  flex: 1;
  height: 8px;
  background-color: #282a36;
  border-radius: 4px;
  overflow: hidden;
}

.next-event-progress {
  height: 100%;
  background: linear-gradient(90deg, #50fa7b, #8be9fd);
  width: 0%;
  transition: width 0.5s linear;
}

.event-imminent .next-event-progress {
  background: linear-gradient(90deg, #ff5555, #ff79c6);
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

/* Combat Panel Styles */
.combat-panel {
  background-color: #282a36;
  border: 1px solid #44475a;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 0 10px rgba(255, 85, 85, 0.3);
}

.combat-panel h4 {
  text-align: center;
  margin-top: 0;
  color: #ff5555;
  font-size: 1.2em;
  margin-bottom: 15px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.combat-content {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.combat-entities {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.combat-entity {
  flex: 1;
  padding: 10px;
  border-radius: 5px;
  background-color: rgba(40, 42, 54, 0.5);
}

.combat-entity.player {
  border-left: 3px solid #8be9fd;
}

.combat-entity.monster {
  border-left: 3px solid #ff5555;
}

.combat-entity-name {
  font-weight: bold;
  margin-bottom: 5px;
  color: #f8f8f2;
}

.combat-vs {
  font-size: 1.5em;
  font-weight: bold;
  color: #6272a4;
  margin: 0 15px;
}

.health-bar-container {
  margin-top: 5px;
}

.health-bar-wrapper {
  height: 10px;
  background-color: #44475a;
  border-radius: 5px;
  overflow: hidden;
  margin-bottom: 5px;
}

.health-bar {
  height: 100%;
  width: 100%;
  transition: width 0.5s ease;
}

.player-health-bar {
  background: linear-gradient(90deg, #8be9fd, #79e3fd);
}

.monster-health-bar {
  background: linear-gradient(90deg, #ff5555, #ff79c6);
}

.health-value {
  font-size: 0.8em;
  color: #6272a4;
  text-align: right;
}

.combat-monster-container {
  display: flex;
  align-items: center;
  gap: 15px;
  margin-bottom: 15px;
}

.monster-image-container {
  height: 120px;
  width: 120px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(40, 42, 54, 0.3);
  border-radius: 5px;
  overflow: hidden;
  position: relative;
}

.monster-image {
  max-height: 100%;
  max-width: 100%;
  object-fit: contain;
}

.monster-placeholder {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  width: 100%;
  font-weight: bold;
  color: #ff5555;
  text-align: center;
  padding: 10px;
  font-size: 0.9em;
}

.monster-stats {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
  background-color: rgba(40, 42, 54, 0.3);
  padding: 10px;
  border-radius: 5px;
}

.monster-stat {
  display: flex;
  justify-content: space-between;
  margin-bottom: 5px;
}

.stat-label {
  color: #6272a4;
  display: inline-block;
  width: 70px; /* Fixed width for stat labels */
}

.stat-value {
  color: #ff79c6;
  font-weight: bold;
  text-align: right;
  margin-left: 10px;
}

.combat-damage-info {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin: 10px 0;
}

.damage-dealt,
.damage-received {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.damage-dealt {
  color: #50fa7b;
}

.damage-received {
  color: #ff5555;
}

.combat-info {
  display: flex;
  flex-direction: column;
  gap: 10px;
  background-color: rgba(40, 42, 54, 0.5);
  padding: 15px;
  border-radius: 5px;
}

.combat-round {
  text-align: center;
  margin-bottom: 10px;
  color: #f8f8f2;
  font-weight: bold;
}

.combat-timer {
  text-align: center;
  margin-top: 10px;
  padding: 5px;
  background-color: #282a36;
  border-radius: 5px;
}

#round-timer {
  color: #f1fa8c;
  font-weight: bold;
}

/* Pulse animation for combat timer */
@keyframes pulse {
  0% { color: #f1fa8c; }
  50% { color: #ff5555; }
  100% { color: #f1fa8c; }
}

.pulse {
  animation: pulse 0.5s infinite;
}

/* Character Status Styles */
.character-status-container {
  background-color: #282a36;
  border: 1px solid #44475a;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 0 10px rgba(80, 250, 123, 0.3);
}

.status-bar {
  display: flex;
  justify-content: space-between;
  gap: 20px;
  align-items: center;
}

.status-item {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.status-label {
  color: #6272a4;
  font-size: 0.9em;
}

.status-bar-container {
  width: 100%;
}

.status-bar-wrapper {
  height: 10px;
  background-color: #44475a;
  border-radius: 5px;
  overflow: hidden;
  margin-bottom: 5px;
}

.status-bar-fill {
  height: 100%;
  width: 0%;
  transition: width 0.5s ease;
}

.health-bar-fill {
  background: linear-gradient(90deg, #8be9fd, #79e3fd);
}

.energy-bar-fill {
  background: linear-gradient(90deg, #50fa7b, #8be9fd);
}

.status-value {
  font-size: 0.8em;
  color: #f8f8f2;
  text-align: right;
}

.recovery-status {
  background-color: rgba(255, 85, 85, 0.2);
  padding: 8px;
  border-radius: 5px;
  text-align: center;
}

.recovery-time {
  color: #ff5555;
  font-weight: bold;
  font-size: 1.1em;
}

@media (max-width: 768px) {
  .status-bar {
    flex-direction: column;
    gap: 10px;
  }
}

/* Combat Window Styles */
.combat-window {
  background-color: #1c1c24;
  border: 2px solid #ff5555;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 30px;
  box-shadow: 0 0 15px rgba(255, 85, 85, 0.4);
  position: relative;
  z-index: 100; /* Higher z-index to ensure it appears above all other elements */
}

.combat-window.hidden {
  display: none;
}

.combat-window h3 {
  text-align: center;
  color: #ff5555;
  margin-top: 0;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  margin-bottom: 20px;
  text-shadow: 0 0 5px rgba(255, 85, 85, 0.5);
}

.combat-status-indicator {
  background-color: rgba(255, 85, 85, 0.15);
  text-align: center;
  padding: 10px;
  border-radius: 4px;
  margin-bottom: 15px;
  border: 1px solid rgba(255, 85, 85, 0.3);
}

.combat-pause-message {
  color: #ff79c6;
  font-weight: bold;
  font-size: 1.1em;
}

.combat-arena {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
}

.combat-entity {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  padding: 15px;
  background-color: rgba(40, 42, 54, 0.7);
  border-radius: 8px;
  position: relative;
}

.player-entity {
  border-left: 4px solid #8be9fd;
}

.monster-entity {
  border-left: 4px solid #ff5555;
}

.entity-image {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  overflow: hidden;
  background-color: #282a36;
  display: flex;
  justify-content: center;
  align-items: center;
  border: 2px solid #44475a;
}

.entity-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.entity-info {
  width: 100%;
  text-align: center;
}

.entity-name {
  font-weight: bold;
  color: #f8f8f2;
  margin-bottom: 8px;
  font-size: 1.1em;
}

.health-bar-label {
  color: #6272a4;
  font-size: 0.8em;
  margin-bottom: 3px;
}

.combat-vs {
  font-size: 1.8em;
  font-weight: bold;
  color: #ff79c6;
  text-shadow: 0 0 5px #ff5555;
  animation: pulse 2s infinite;
}

.combat-details {
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
}

.monster-details, .combat-info {
  flex: 1;
  background-color: rgba(40, 42, 54, 0.5);
  padding: 15px;
  border-radius: 8px;
}

.monster-stats {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.combat-damage-info {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin: 10px 0;
}

.damage-dealt,
.damage-received {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.damage-dealt {
  color: #50fa7b;
}

.damage-received {
  color: #ff5555;
}

.combat-info {
  display: flex;
  flex-direction: column;
  gap: 10px;
  background-color: rgba(40, 42, 54, 0.5);
  padding: 15px;
  border-radius: 5px;
}

.combat-round {
  text-align: center;
  margin-bottom: 10px;
  color: #f8f8f2;
  font-weight: bold;
}

.combat-timer {
  text-align: center;
  margin-top: 10px;
  padding: 5px;
  background-color: #282a36;
  border-radius: 5px;
}

#round-timer {
  color: #f1fa8c;
  font-weight: bold;
}

/* Pulse animation for combat timer */
@keyframes pulse {
  0% { color: #f1fa8c; }
  50% { color: #ff5555; }
  100% { color: #f1fa8c; }
}

.pulse {
  animation: pulse 0.5s infinite;
}

/* Character Status Styles */
.character-status-container {
  background-color: #282a36;
  border: 1px solid #44475a;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 20px;
  box-shadow: 0 0 10px rgba(80, 250, 123, 0.3);
}

.status-bar {
  display: flex;
  justify-content: space-between;
  gap: 20px;
  align-items: center;
}

.status-item {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.status-label {
  color: #6272a4;
  font-size: 0.9em;
}

.status-bar-container {
  width: 100%;
}

.status-bar-wrapper {
  height: 10px;
  background-color: #44475a;
  border-radius: 5px;
  overflow: hidden;
  margin-bottom: 5px;
}

.status-bar-fill {
  height: 100%;
  width: 0%;
  transition: width 0.5s ease;
}

.health-bar-fill {
  background: linear-gradient(90deg, #8be9fd, #79e3fd);
}

.energy-bar-fill {
  background: linear-gradient(90deg, #50fa7b, #8be9fd);
}

.status-value {
  font-size: 0.8em;
  color: #f8f8f2;
  text-align: right;
}

.recovery-status {
  background-color: rgba(255, 85, 85, 0.2);
  padding: 8px;
  border-radius: 5px;
  text-align: center;
}

.recovery-time {
  color: #ff5555;
  font-weight: bold;
  font-size: 1.1em;
}

@media (max-width: 768px) {
  .status-bar {
    flex-direction: column;
    gap: 10px;
  }
}
</style> 